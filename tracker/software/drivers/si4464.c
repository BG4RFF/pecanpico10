/**
 * Si4464 driver specialized for APRS transmissions. Modulation concept has been taken
 * from Stefan Biereigel DK3SB.
 * @see http://www.github.com/thasti/utrak
 */

#include "ch.h"
#include "hal.h"
#include "si4464.h"
#include "debug.h"
#include "types.h"
#include <string.h>

static const SPIConfig ls_spicfg = {
	.ssport	= PAL_PORT(LINE_RADIO_CS),
	.sspad	= PAL_PAD(LINE_RADIO_CS),
	.cr1	= SPI_CR1_MSTR
};
#define getSPIDriver() &ls_spicfg

static uint32_t outdiv;
static bool initialized = false;
static int16_t lastTemp;

static void Si4464_write(const uint8_t* txData, uint32_t len) {
	// Transmit data by SPI
	uint8_t rxData[len];
	
	// SPI transfer
	spiAcquireBus(&SPID3);
	spiStart(&SPID3, getSPIDriver());

	spiSelect(&SPID3);
	spiExchange(&SPID3, len, txData, rxData);
	spiUnselect(&SPID3);

	// Reqest ACK by Si4464
	rxData[1] = 0x00;
	while(rxData[1] != 0xFF) {

		// Request ACK by Si4464
		uint8_t rx_ready[] = {0x44};

		// SPI transfer
		spiSelect(&SPID3);
		spiExchange(&SPID3, 3, rx_ready, rxData);
		spiUnselect(&SPID3);
	}
	spiStop(&SPID3);
	spiReleaseBus(&SPID3);
}

/**
 * Read register from Si4464. First Register CTS is included.
 */
static void Si4464_read(const uint8_t* txData, uint32_t txlen, uint8_t* rxData, uint32_t rxlen) {
	// Transmit data by SPI
	uint8_t null_spi[txlen];
	// SPI transfer
	spiAcquireBus(&SPID3);
	spiStart(&SPID3, getSPIDriver());

	spiSelect(&SPID3);
	spiExchange(&SPID3, txlen, txData, null_spi);
	spiUnselect(&SPID3);

	// Reqest ACK by Si4464
	rxData[1] = 0x00;
	while(rxData[1] != 0xFF) {

		// Request ACK by Si4464
		uint16_t rx_ready[rxlen];
		rx_ready[0] = 0x44;

		// SPI transfer
		spiSelect(&SPID3);
		spiExchange(&SPID3, rxlen, rx_ready, rxData);
		spiUnselect(&SPID3);
	}
	spiStop(&SPID3);
	spiReleaseBus(&SPID3);
}

/**
 * Initializes Si4464 transceiver chip. Adjustes the frequency which is shifted by variable
 * oscillator voltage.
 * @param mv Oscillator voltage in mv
 */
void Si4464_Init(void) {
	// Configure Radio pins
	palSetLineMode(LINE_SPI_SCK, PAL_MODE_ALTERNATE(6) | PAL_STM32_OSPEED_HIGHEST);		// SCK
	palSetLineMode(LINE_SPI_MISO, PAL_MODE_ALTERNATE(6) | PAL_STM32_OSPEED_HIGHEST);	// MISO
	palSetLineMode(LINE_SPI_MOSI, PAL_MODE_ALTERNATE(6) | PAL_STM32_OSPEED_HIGHEST);	// MOSI
	palSetLineMode(LINE_RADIO_CS, PAL_MODE_OUTPUT_PUSHPULL | PAL_STM32_OSPEED_HIGHEST);	// RADIO CS
	palSetLineMode(LINE_SD_CS, PAL_MODE_OUTPUT_PUSHPULL | PAL_STM32_OSPEED_HIGHEST);	// SD CS
	palSetLineMode(LINE_RADIO_SDN, PAL_MODE_OUTPUT_PUSHPULL);							// RADIO SDN
	palSetLineMode(LINE_TCXO_EN, PAL_MODE_OUTPUT_PUSHPULL);								// Oscillator

	// Pull CS of all SPI slaves high
	palSetLine(LINE_SD_CS);
	palSetLine(LINE_RADIO_CS);

	// Reset radio
	palSetLine(LINE_RADIO_SDN);
	palSetLine(LINE_TCXO_EN); // Activate Oscillator
	chThdSleep(TIME_MS2I(10));

	// Power up transmitter
	palClearLine(LINE_RADIO_SDN);	// Radio SDN low (power up transmitter)
	chThdSleep(TIME_MS2I(10));		// Wait for transmitter to power up

	// Power up (transmits oscillator type)
	const uint8_t x3 = (RADIO_CLK >> 24) & 0x0FF;
	const uint8_t x2 = (RADIO_CLK >> 16) & 0x0FF;
	const uint8_t x1 = (RADIO_CLK >>  8) & 0x0FF;
	const uint8_t x0 = (RADIO_CLK >>  0) & 0x0FF;
	const uint8_t init_command[] = {0x02, 0x01, (RADIO_TCXO_EN & 0x1), x3, x2, x1, x0};
	Si4464_write(init_command, 7);
	chThdSleep(TIME_MS2I(25));

	// Set transmitter GPIOs
	uint8_t gpio_pin_cfg_command[] = {
		0x13,	// Command type = GPIO settings
		0x00,	// GPIO0        GPIO_MODE = DONOTHING
		0x14,	// GPIO1        GPIO_MODE = RX_DATA
		0x21,	// GPIO2        GPIO_MODE = RX_STATE
		0x20,	// GPIO3        GPIO_MODE = TX_STATE
		0x1B,	// NIRQ         NIRQ_MODE = CCA
		0x0B,	// SDO          SDO_MODE = SDO
		0x00	// GEN_CONFIG
	};
	Si4464_write(gpio_pin_cfg_command, 8);
	chThdSleep(TIME_MS2I(25));

	#if !RADIO_TCXO_EN
	// Set internal capacitance for XTAL in-/ and output
	uint8_t set_global_xo_tune[] = {0x11, 0x00, 0x01, 0x00, 0x52};
	Si4464_write(set_global_xo_tune, 5);
	#endif

	// Disable Fast Response Registers
	for(uint8_t i=0; i<4; i++) {
		uint8_t set_frr_ctl_mode[] = {0x11, 0x02, 0x01, i, 0x00};
		Si4464_write(set_frr_ctl_mode, 5);
	}

	// Set global config: FIFO=129byte, SEQUENCER_MODE and RESERVED bit (this was generated by WDS, I dont know why the reserved bit is set which should be 0)
	const uint8_t set_global_config[] = {0x11, 0x00, 0x01, 0x03, 0x70};
	Si4464_write(set_global_config, 5);

	// Reset FIFO
	const uint8_t reset_fifo[] = {0x15, 0x01};
	Si4464_write(reset_fifo, 2);
	const uint8_t unreset_fifo[] = {0x15, 0x00};
	Si4464_write(unreset_fifo, 2);

	// Setup RSSI: CHECK_THRESH_AT_LATCH disabled, AVERAGE=AVERAGE4, LATCH disabled
	const uint8_t set_modem_rssi_control[] = {0x11, 0x20, 0x01, 0x4C, 0x00};
	Si4464_write(set_modem_rssi_control, 5);

	// Set RSSI threshold
	const uint8_t set_modem_rssi_threshold[] = {0x11, 0x20, 0x01, 0x4A, 0x4F};
	Si4464_write(set_modem_rssi_threshold, 5);

	// Disable preamble (TX)
	const uint8_t set_preamble_tx_length[] = {0x11, 0x10, 0x01, 0x00, 0x00};
	Si4464_write(set_preamble_tx_length, 5);

	// Setup preamble (RX)
	const uint8_t set_preamble_config_std1[] = {0x11, 0x10, 0x01, 0x01, 0x14};
	Si4464_write(set_preamble_config_std1, 5);

	// Disable Manchester encoding
	const uint8_t set_modem_map_control[] = {0x11, 0x20, 0x01, 0x01, 0x00};
	Si4464_write(set_modem_map_control, 5);

	// Do not transmit sync word
	const uint8_t no_sync_word[] = {0x11, 0x11, 0x01, 0x00, (0x01 << 7)};
	Si4464_write(no_sync_word, 5);

	// transmit LSB first, disable RX PH
	const uint8_t use_lsb_first[] = {0x11, 0x12, 0x01, 0x06, 0x41};
	Si4464_write(use_lsb_first, 5);

	// Select phase source
	const uint8_t set_mdm_ctrl[] = {0x11, 0x20, 0x01, 0x19, 0x80};
	Si4464_write(set_mdm_ctrl, 5);

	// Set IF frequency (RX)
	const uint8_t set_if_freq[] = {0x11, 0x20, 0x03, 0x1B, 0x02, 0x80, 0x00};
	Si4464_write(set_if_freq, 7);

	// Set decimation
	#if RADIO_CLK == 30000000
	const uint8_t set_decimation_cfg[] = {0x11, 0x20, 0x02, 0x1E, 0x30, 0x20};
	#elif RADIO_CLK == 26000000
	const uint8_t set_decimation_cfg[] = {0x11, 0x20, 0x02, 0x1E, 0x20, 0x10};
	#endif
	Si4464_write(set_decimation_cfg, 6);


	// Set RX BCR/Slicer oversampling rate
	#if RADIO_CLK == 30000000
	const uint8_t set_bcr_osr[] = {0x11, 0x20, 0x02, 0x22, 0x00, 0x47};
	#elif RADIO_CLK == 26000000
	const uint8_t set_bcr_osr[] = {0x11, 0x20, 0x02, 0x22, 0x00, 0x52};
	#endif
	Si4464_write(set_bcr_osr, 6);

	// Set RX BCR NCO offset value
	#if RADIO_CLK == 30000000
	const uint8_t set_bcr_nco_offset[] = {0x11, 0x20, 0x03, 0x24, 0x07, 0x35, 0x7E};
	#elif RADIO_CLK == 26000000
	const uint8_t set_bcr_nco_offset[] = {0x11, 0x20, 0x03, 0x24, 0x06, 0x3D, 0x10};
	#endif
	Si4464_write(set_bcr_nco_offset, 7);

	// Set RX BCR loop gain value
	#if RADIO_CLK == 30000000
	const uint8_t set_bcr_gain[] = {0x11, 0x20, 0x02, 0x27, 0x03, 0x9B};
	#elif RADIO_CLK == 26000000
	const uint8_t set_bcr_gain[] = {0x11, 0x20, 0x02, 0x27, 0x03, 0x1F};
	#endif
	Si4464_write(set_bcr_gain, 6);

	// Set RX BCR loop gear control
	const uint8_t set_bcr_gear[] = {0x11, 0x20, 0x01, 0x29, 0x00};
	Si4464_write(set_bcr_gear, 5);

	// Set miscellaneous control bits for the RX BCR loop
	const uint8_t set_bcr_misc[] = {0x11, 0x20, 0x01, 0x2A, 0xC2};
	Si4464_write(set_bcr_misc, 5);


	// Set AFC gear
	const uint8_t set_afc_gear[] = {0x11, 0x20, 0x01, 0x2C, 0x54};
	Si4464_write(set_afc_gear, 5);

	// Set AFC wait
	const uint8_t set_afc_wait[] = {0x11, 0x20, 0x01, 0x2D, 0x36};
	Si4464_write(set_afc_wait, 5);

	// Set AFC gain
	#if RADIO_CLK == 30000000
	const uint8_t set_afc_gain[] = {0x11, 0x20, 0x02, 0x2E, 0x82, 0x00};
	#elif RADIO_CLK == 26000000
	const uint8_t set_afc_gain[] = {0x11, 0x20, 0x02, 0x2E, 0x82, 0xAA};
	#endif
	Si4464_write(set_afc_gain, 6);

	// Set AFC limiter
	const uint8_t set_afc_limiter[] = {0x11, 0x20, 0x02, 0x30, 0x00, 0x95};
	Si4464_write(set_afc_limiter, 6);

	// Set AFC misc
	const uint8_t set_afc_misc[] = {0x11, 0x20, 0x01, 0x32, 0x80};
	Si4464_write(set_afc_misc, 5);


	// Set AGC control
	const uint8_t set_agc_control[] = {0x11, 0x20, 0x01, 0x35, 0xE2};
	Si4464_write(set_agc_control, 5);

	// Set AGC RFPD decay
	#if RADIO_CLK == 30000000
	const uint8_t set_agc_rfpd_decay[] = {0x11, 0x20, 0x01, 0x39, 0x10};
	#elif RADIO_CLK == 26000000
	const uint8_t set_agc_rfpd_decay[] = {0x11, 0x20, 0x01, 0x39, 0x12};
	#endif
	Si4464_write(set_agc_rfpd_decay, 5);

	// Set AGC RFPD decay
	#if RADIO_CLK == 30000000
	const uint8_t set_agc_ifpd_decay[] = {0x11, 0x20, 0x01, 0x3a, 0x10};
	#elif RADIO_CLK == 26000000
	const uint8_t set_agc_ifpd_decay[] = {0x11, 0x20, 0x01, 0x3a, 0x12};
	#endif
	Si4464_write(set_agc_ifpd_decay, 5);


	// 4FSK settings
	const uint8_t set_fsk4_gain1[] = {0x11, 0x20, 0x01, 0x3B, 0x00};
	Si4464_write(set_fsk4_gain1, 5);
	const uint8_t set_fsk4_gain0[] = {0x11, 0x20, 0x01, 0x3C, 0x02};
	Si4464_write(set_fsk4_gain0, 5);
	const uint8_t set_fsk4_th[] = {0x11, 0x20, 0x02, 0x3D, 0x02, 0x6D};
	Si4464_write(set_fsk4_th, 6);
	const uint8_t set_fsk4_map[] = {0x11, 0x20, 0x01, 0x3F, 0x00};
	Si4464_write(set_fsk4_map, 5);

	const uint8_t set_ook_pdtc[] = {0x11, 0x20, 0x01, 0x40, 0x28};
	Si4464_write(set_ook_pdtc, 5);

	#if RADIO_CLK == 30000000
	const uint8_t set_ook_cnt1[] = {0x11, 0x20, 0x01, 0x42, 0x85};
	const uint8_t set_ook_misc[] = {0x11, 0x20, 0x01, 0x43, 0x23};
	#elif RADIO_CLK == 26000000
	const uint8_t set_ook_cnt1[] = {0x11, 0x20, 0x01, 0x42, 0x84};
	const uint8_t set_ook_misc[] = {0x11, 0x20, 0x01, 0x43, 0x03};
	#endif
	Si4464_write(set_ook_cnt1, 5);
	Si4464_write(set_ook_misc, 5);

	const uint8_t set_dsa_ctrl1[] = {0x11, 0x20, 0x01, 0x5B, 0xA0};
	Si4464_write(set_dsa_ctrl1, 5);
	const uint8_t set_dsa_ctrl2[] = {0x11, 0x20, 0x01, 0x5C, 0x04};
	Si4464_write(set_dsa_ctrl2, 5);

	const uint8_t set_raw_search[] = {0x11, 0x20, 0x01, 0x44, 0xD6};
	Si4464_write(set_raw_search, 5);


	const uint8_t set_raw_control[] = {0x11, 0x20, 0x01, 0x45, 0x8F};
	Si4464_write(set_raw_control, 5);

	#if RADIO_CLK == 30000000
	const uint8_t set_raw_eye[] = {0x11, 0x20, 0x01, 0x46, 0x00, 0x11};
	#elif RADIO_CLK == 26000000
	const uint8_t set_raw_eye[] = {0x11, 0x20, 0x01, 0x46, 0x00, 0x0F};
	#endif
	Si4464_write(set_raw_eye, 6);

	const uint8_t set_ant_div_mode[] = {0x11, 0x20, 0x01, 0x48, 0x01};
	Si4464_write(set_ant_div_mode, 5);

	const uint8_t set_ant_div_control[] = {0x11, 0x20, 0x01, 0x49, 0x80};
	Si4464_write(set_ant_div_control, 5);

	const uint8_t set_rssi_comp[] = {0x11, 0x20, 0x01, 0x4E, 0x40};
	Si4464_write(set_rssi_comp, 5);


	// Set CHFLT Filter
	const uint8_t set_chflt1[] = {0x11, 0x21, 0x0C, 0x00, 0xA2, 0xA0, 0x97, 0x8A, 0x79, 0x66, 0x52, 0x3F, 0x2E, 0x1F, 0x14, 0x0B};
	Si4464_write(set_chflt1, 16);

	const uint8_t set_chflt2[] = {0x11, 0x21, 0x0C, 0x0C, 0x06, 0x02, 0x00, 0x00, 0x00, 0x00, 0xA2, 0xA0, 0x97, 0x8A, 0x79, 0x66};
	Si4464_write(set_chflt2, 16);

	const uint8_t set_chflt3[] = {0x11, 0x21, 0x0C, 0x18, 0x52, 0x3F, 0x2E, 0x1F, 0x14, 0x0B, 0x06, 0x02, 0x00, 0x00, 0x00, 0x00};
	Si4464_write(set_chflt3, 16);


	// Temperature readout
	lastTemp = Si4464_getTemperature();
	TRACE_INFO("SI   > Transmitter temperature %d degC", lastTemp/100);
	initialized = true;
}

void init145_175(void) {
	// Configure Radio pins
	palSetLineMode(LINE_SPI_SCK, PAL_MODE_ALTERNATE(6) | PAL_STM32_OSPEED_HIGHEST);		// SCK
	palSetLineMode(LINE_SPI_MISO, PAL_MODE_ALTERNATE(6) | PAL_STM32_OSPEED_HIGHEST);	// MISO
	palSetLineMode(LINE_SPI_MOSI, PAL_MODE_ALTERNATE(6) | PAL_STM32_OSPEED_HIGHEST);	// MOSI
	palSetLineMode(LINE_RADIO_CS, PAL_MODE_OUTPUT_PUSHPULL | PAL_STM32_OSPEED_HIGHEST);	// RADIO CS
	palSetLineMode(LINE_SD_CS, PAL_MODE_OUTPUT_PUSHPULL | PAL_STM32_OSPEED_HIGHEST);	// SD CS
	palSetLineMode(LINE_RADIO_SDN, PAL_MODE_OUTPUT_PUSHPULL);							// RADIO SDN
	palSetLineMode(LINE_TCXO_EN, PAL_MODE_OUTPUT_PUSHPULL);								// Oscillator

	// Pull CS of all SPI slaves high
	palSetLine(LINE_SD_CS);
	palSetLine(LINE_RADIO_CS);

	// Reset radio
	palSetLine(LINE_RADIO_SDN);
	palSetLine(LINE_TCXO_EN); // Activate Oscillator
	chThdSleep(TIME_MS2I(10));

	// Power up transmitter
	palClearLine(LINE_RADIO_SDN);	// Radio SDN low (power up transmitter)
	chThdSleep(TIME_MS2I(10));		// Wait for transmitter to power up

	// Power up (transmits oscillator type)
	const uint8_t x3 = (RADIO_CLK >> 24) & 0x0FF;
	const uint8_t x2 = (RADIO_CLK >> 16) & 0x0FF;
	const uint8_t x1 = (RADIO_CLK >>  8) & 0x0FF;
	const uint8_t x0 = (RADIO_CLK >>  0) & 0x0FF;
	const uint8_t init_command[] = {0x02, 0x01, (RADIO_TCXO_EN & 0x1), x3, x2, x1, x0};
	Si4464_write(init_command, 7);
	chThdSleep(TIME_MS2I(25));

	// Set transmitter GPIOs
	uint8_t gpio_pin_cfg_command[] = {
		0x13,	// Command type = GPIO settings
		0x00,	// GPIO0        GPIO_MODE = DONOTHING
		0x14,	// GPIO1        GPIO_MODE = RX_DATA
		0x21,	// GPIO2        GPIO_MODE = RX_STATE
		0x20,	// GPIO3        GPIO_MODE = TX_STATE
		0x1B,	// NIRQ         NIRQ_MODE = CCA
		0x0B,	// SDO          SDO_MODE = SDO
		0x00	// GEN_CONFIG
	};
	Si4464_write(gpio_pin_cfg_command, 8);
	chThdSleep(TIME_MS2I(25));

const uint8_t a1[] =  {0x11, 0x00, 0x01, 0x00, 0x52};
const uint8_t a2[] =  {0x11, 0x02, 0x01, 0x00, 0x00};
const uint8_t a3[] =  {0x11, 0x02, 0x01, 0x01, 0x00};
const uint8_t a4[] =  {0x11, 0x02, 0x01, 0x02, 0x00};
const uint8_t a5[] =  {0x11, 0x02, 0x01, 0x03, 0x00};
const uint8_t a6[] =  {0x11, 0x01, 0x01, 0x00, 0x00};
const uint8_t a7[] =  {0x11, 0x00, 0x01, 0x03, 0x60};
const uint8_t a8[] =  {0x11, 0x00, 0x01, 0x01, 0x00};
const uint8_t a9[] =  {0x11, 0x20, 0x01, 0x4c, 0x00};
const uint8_t a10[] = {0x11, 0x20, 0x01, 0x4a, 0x6F};
const uint8_t a11[] = {0x11, 0x10, 0x01, 0x01, 0x14};
const uint8_t a12[] = {0x11, 0x12, 0x01, 0x06, 0x40};
const uint8_t a13[] = {0x11, 0x20, 0x01, 0x00, 0x0A};
const uint8_t a14[] = {0x11, 0x20, 0x01, 0x01, 0x00};
const uint8_t a15[] = {0x11, 0x20, 0x01, 0x02, 0x07};
const uint8_t a16[] = {0x11, 0x20, 0x01, 0x51, 0x0D};
const uint8_t a17[] = {0x11, 0x20, 0x01, 0x03, 0x04};
const uint8_t a18[] = {0x11, 0x20, 0x01, 0x04, 0x07};
const uint8_t a19[] = {0x11, 0x20, 0x01, 0x05, 0x40};
const uint8_t a20[] = {0x11, 0x20, 0x01, 0x06, 0x01};
const uint8_t a21[] = {0x11, 0x20, 0x01, 0x07, 0x8C};
const uint8_t a22[] = {0x11, 0x20, 0x01, 0x08, 0xBA};
const uint8_t a23[] = {0x11, 0x20, 0x01, 0x09, 0x80};
const uint8_t a24[] = {0x11, 0x20, 0x01, 0x0a, 0x00};
const uint8_t a25[] = {0x11, 0x20, 0x01, 0x0b, 0x00};
const uint8_t a26[] = {0x11, 0x20, 0x01, 0x0c, 0x79};
const uint8_t a27[] = {0x11, 0x20, 0x01, 0x18, 0x01};
const uint8_t a28[] = {0x11, 0x22, 0x01, 0x03, 0x3D};
const uint8_t a29[] = {0x11, 0x40, 0x01, 0x00, 0x41};
const uint8_t a30[] = {0x11, 0x40, 0x01, 0x01, 0x0B};
const uint8_t a31[] = {0x11, 0x40, 0x01, 0x02, 0xB1};
const uint8_t a32[] = {0x11, 0x40, 0x01, 0x03, 0x3B};
const uint8_t a33[] = {0x11, 0x40, 0x01, 0x04, 0x0B};
const uint8_t a34[] = {0x11, 0x40, 0x01, 0x05, 0xD1};
const uint8_t a35[] = {0x11, 0x40, 0x01, 0x06, 0x20};
const uint8_t a36[] = {0x11, 0x40, 0x01, 0x07, 0xFA};
const uint8_t a37[] = {0x11, 0x20, 0x01, 0x19, 0x80};
const uint8_t a38[] = {0x11, 0x20, 0x01, 0x1a, 0x08};
const uint8_t a39[] = {0x11, 0x20, 0x01, 0x1b, 0x02};
const uint8_t a40[] = {0x11, 0x20, 0x01, 0x1c, 0x80};
const uint8_t a41[] = {0x11, 0x20, 0x01, 0x1d, 0x00};
const uint8_t a42[] = {0x11, 0x20, 0x01, 0x1e, 0x20};
const uint8_t a43[] = {0x11, 0x20, 0x01, 0x1f, 0x10};
const uint8_t a44[] = {0x11, 0x20, 0x01, 0x22, 0x00};
const uint8_t a45[] = {0x11, 0x20, 0x01, 0x23, 0x52};
const uint8_t a46[] = {0x11, 0x20, 0x01, 0x24, 0x06};
const uint8_t a47[] = {0x11, 0x20, 0x01, 0x25, 0x3D};
const uint8_t a48[] = {0x11, 0x20, 0x01, 0x25, 0x10};
const uint8_t a49[] = {0x11, 0x20, 0x01, 0x27, 0x03};
const uint8_t a50[] = {0x11, 0x20, 0x01, 0x28, 0x1F};
const uint8_t a51[] = {0x11, 0x20, 0x01, 0x29, 0x00};
const uint8_t a52[] = {0x11, 0x20, 0x01, 0x2a, 0xC2};
const uint8_t a53[] = {0x11, 0x20, 0x01, 0x2c, 0x54};
const uint8_t a54[] = {0x11, 0x20, 0x01, 0x2d, 0x36};
const uint8_t a55[] = {0x11, 0x20, 0x01, 0x2e, 0x82};
const uint8_t a56[] = {0x11, 0x20, 0x01, 0x2f, 0xAA};
const uint8_t a57[] = {0x11, 0x20, 0x01, 0x30, 0x00};
const uint8_t a58[] = {0x11, 0x20, 0x01, 0x31, 0x95};
const uint8_t a59[] = {0x11, 0x20, 0x01, 0x32, 0x80};
const uint8_t a60[] = {0x11, 0x20, 0x01, 0x35, 0xE2};
const uint8_t a61[] = {0x11, 0x20, 0x01, 0x38, 0x11};
const uint8_t a62[] = {0x11, 0x20, 0x01, 0x39, 0x12};
const uint8_t a63[] = {0x11, 0x20, 0x01, 0x3a, 0x12};
const uint8_t a64[] = {0x11, 0x20, 0x01, 0x3b, 0x00};
const uint8_t a65[] = {0x11, 0x20, 0x01, 0x3c, 0x02};
const uint8_t a66[] = {0x11, 0x20, 0x01, 0x3d, 0x02};
const uint8_t a67[] = {0x11, 0x20, 0x01, 0x3e, 0x6D};
const uint8_t a68[] = {0x11, 0x20, 0x01, 0x3f, 0x00};
const uint8_t a69[] = {0x11, 0x20, 0x01, 0x40, 0x28};
const uint8_t a70[] = {0x11, 0x20, 0x01, 0x42, 0x84};
const uint8_t a71[] = {0x11, 0x20, 0x01, 0x43, 0x03};
const uint8_t a72[] = {0x11, 0x20, 0x01, 0x44, 0xD6};
const uint8_t a73[] = {0x11, 0x20, 0x01, 0x45, 0x8F};
const uint8_t a74[] = {0x11, 0x20, 0x01, 0x46, 0x00};
const uint8_t a75[] = {0x11, 0x20, 0x01, 0x47, 0x0F};
const uint8_t a76[] = {0x11, 0x20, 0x01, 0x48, 0x01};
const uint8_t a77[] = {0x11, 0x20, 0x01, 0x49, 0x80};
const uint8_t a78[] = {0x11, 0x20, 0x01, 0x4e, 0x40};

Si4464_write(a2, 5);
Si4464_write(a3, 5);
Si4464_write(a4, 5);
Si4464_write(a5, 5);
Si4464_write(a6, 5);
Si4464_write(a7, 5);
Si4464_write(a8, 5);
Si4464_write(a9, 5);
Si4464_write(a10, 5);
Si4464_write(a11, 5);
Si4464_write(a12, 5);
Si4464_write(a13, 5);
Si4464_write(a14, 5);
Si4464_write(a15, 5);
Si4464_write(a16, 5);
Si4464_write(a17, 5);
Si4464_write(a18, 5);
Si4464_write(a19, 5);
Si4464_write(a20, 5);
Si4464_write(a21, 5);
Si4464_write(a22, 5);
Si4464_write(a23, 5);
Si4464_write(a24, 5);
Si4464_write(a25, 5);
Si4464_write(a26, 5);
Si4464_write(a27, 5);
Si4464_write(a28, 5);
Si4464_write(a29, 5);
Si4464_write(a30, 5);
Si4464_write(a31, 5);
Si4464_write(a32, 5);
Si4464_write(a33, 5);
Si4464_write(a34, 5);
Si4464_write(a35, 5);
Si4464_write(a36, 5);
Si4464_write(a37, 5);
Si4464_write(a38, 5);
Si4464_write(a39, 5);
Si4464_write(a40, 5);
Si4464_write(a41, 5);
Si4464_write(a42, 5);
Si4464_write(a43, 5);
Si4464_write(a44, 5);
Si4464_write(a45, 5);
Si4464_write(a46, 5);
Si4464_write(a47, 5);
Si4464_write(a48, 5);
Si4464_write(a49, 5);
Si4464_write(a50, 5);
Si4464_write(a51, 5);
Si4464_write(a52, 5);
Si4464_write(a53, 5);
Si4464_write(a54, 5);
Si4464_write(a55, 5);
Si4464_write(a56, 5);
Si4464_write(a57, 5);
Si4464_write(a58, 5);
Si4464_write(a59, 5);
Si4464_write(a60, 5);
Si4464_write(a61, 5);
Si4464_write(a62, 5);
Si4464_write(a63, 5);
Si4464_write(a64, 5);
Si4464_write(a65, 5);
Si4464_write(a66, 5);
Si4464_write(a67, 5);
Si4464_write(a68, 5);
Si4464_write(a69, 5);
Si4464_write(a70, 5);
Si4464_write(a71, 5);
Si4464_write(a72, 5);
Si4464_write(a73, 5);
Si4464_write(a74, 5);
Si4464_write(a75, 5);
Si4464_write(a76, 5);
Si4464_write(a77, 5);
Si4464_write(a78, 5);

	// Set CHFLT Filter
	const uint8_t set_chflt1[] = {0x11, 0x21, 0x0C, 0x00, 0xA2, 0xA0, 0x97, 0x8A, 0x79, 0x66, 0x52, 0x3F, 0x2E, 0x1F, 0x14, 0x0B};
	Si4464_write(set_chflt1, 16);

	const uint8_t set_chflt2[] = {0x11, 0x21, 0x0C, 0x0C, 0x06, 0x02, 0x00, 0x00, 0x00, 0x00, 0xA2, 0xA0, 0x97, 0x8A, 0x79, 0x66};
	Si4464_write(set_chflt2, 16);

	const uint8_t set_chflt3[] = {0x11, 0x21, 0x0C, 0x18, 0x52, 0x3F, 0x2E, 0x1F, 0x14, 0x0B, 0x06, 0x02, 0x00, 0x00, 0x00, 0x00};
	Si4464_write(set_chflt3, 16);



}

void setFrequency(uint32_t freq, uint16_t shift) {
	// Set the output divider according to recommended ranges given in Si4464 datasheet
	uint32_t band = 0;
	if(freq < 705000000UL) {outdiv = 6;  band = 1;};
	if(freq < 525000000UL) {outdiv = 8;  band = 2;};
	if(freq < 353000000UL) {outdiv = 12; band = 3;};
	if(freq < 239000000UL) {outdiv = 16; band = 4;};
	if(freq < 177000000UL) {outdiv = 24; band = 5;};

	// Set the band parameter
	uint32_t sy_sel = 8;
	uint8_t set_band_property_command[] = {0x11, 0x20, 0x01, 0x51, (band + sy_sel)};
	Si4464_write(set_band_property_command, 5);

	// Set the PLL parameters
	uint32_t f_pfd = 2 * RADIO_CLK / outdiv;
	uint32_t n = ((uint32_t)(freq / f_pfd)) - 1;
	float ratio = (float)freq / (float)f_pfd;
	float rest  = ratio - (float)n;

	uint32_t m = (uint32_t)(rest * 524288UL);
	uint32_t m2 = m >> 16;
	uint32_t m1 = (m - m2 * 0x10000) >> 8;
	uint32_t m0 = (m - m2 * 0x10000 - (m1 << 8));

	uint32_t channel_increment = 524288 * outdiv * shift / (2 * RADIO_CLK);
	uint8_t c1 = channel_increment / 0x100;
	uint8_t c0 = channel_increment - (0x100 * c1);

	uint8_t set_frequency_property_command[] = {0x11, 0x40, 0x04, 0x00, n, m2, m1, m0, c1, c0};
	Si4464_write(set_frequency_property_command, 10);

	uint32_t x = ((((uint32_t)1 << 19) * outdiv * 1300.0)/(2*RADIO_CLK))*2;
	uint8_t x2 = (x >> 16) & 0xFF;
	uint8_t x1 = (x >>  8) & 0xFF;
	uint8_t x0 = (x >>  0) & 0xFF;
	uint8_t set_deviation[] = {0x11, 0x20, 0x03, 0x0a, x2, x1, x0};
	Si4464_write(set_deviation, 7);
}

void setShift(uint16_t shift) {
	if(!shift)
		return;

	float units_per_hz = (( 0x40000 * outdiv ) / (float)RADIO_CLK);

	// Set deviation for 2FSK
	uint32_t modem_freq_dev = (uint32_t)(units_per_hz * shift / 2.0 );
	uint8_t modem_freq_dev_0 = 0xFF & modem_freq_dev;
	uint8_t modem_freq_dev_1 = 0xFF & (modem_freq_dev >> 8);
	uint8_t modem_freq_dev_2 = 0xFF & (modem_freq_dev >> 16);

	uint8_t set_modem_freq_dev_command[] = {0x11, 0x20, 0x03, 0x0A, modem_freq_dev_2, modem_freq_dev_1, modem_freq_dev_0};
	Si4464_write(set_modem_freq_dev_command, 7);
}

void setModemAFSK(void) {
	// Setup the NCO modulo and oversampling mode
	uint32_t s = RADIO_CLK / 10;
	uint8_t f3 = (s >> 24) & 0xFF;
	uint8_t f2 = (s >> 16) & 0xFF;
	uint8_t f1 = (s >>  8) & 0xFF;
	uint8_t f0 = (s >>  0) & 0xFF;
	uint8_t setup_oversampling[] = {0x11, 0x20, 0x04, 0x06, f3, f2, f1, f0};
	Si4464_write(setup_oversampling, 8);

	// Setup the NCO data rate for APRS
	const uint8_t setup_data_rate[] = {0x11, 0x20, 0x03, 0x03, 0x00, 0x33, 0x90};
	Si4464_write(setup_data_rate, 7);

	// Use 2GFSK from FIFO (PH)
	const uint8_t use_2fsk[] = {0x11, 0x20, 0x01, 0x00, 0x03};
	Si4464_write(use_2fsk, 5);

	// Set AFSK filter
	const uint8_t coeff[] = {0x81, 0x9f, 0xc4, 0xee, 0x18, 0x3e, 0x5c, 0x70, 0x76};
	uint8_t i;
	for(i=0; i<sizeof(coeff); i++) {
		uint8_t msg[] = {0x11, 0x20, 0x01, 0x17-i, coeff[i]};
		Si4464_write(msg, 5);
	}
}

void setModemAFSK_RX(void) {
	// Setup the NCO modulo and oversampling mode
	uint32_t s = RADIO_CLK;
	uint8_t f3 = (s >> 24) & 0xFF;
	uint8_t f2 = (s >> 16) & 0xFF;
	uint8_t f1 = (s >>  8) & 0xFF;
	uint8_t f0 = (s >>  0) & 0xFF;
	uint8_t setup_oversampling[] = {0x11, 0x20, 0x04, 0x06, f3, f2, f1, f0};
	Si4464_write(setup_oversampling, 8);

	// Setup the NCO data rate for APRS
	const uint8_t setup_data_rate[] = {0x11, 0x20, 0x03, 0x03, 0x04, 0x07, 0x40};
	Si4464_write(setup_data_rate, 7);

	// Use 2FSK in DIRECT_MODE
	const uint8_t use_2fsk[] = {0x11, 0x20, 0x01, 0x00, 0x0A};
	Si4464_write(use_2fsk, 5);
}

void setModem2FSK(fsk_conf_t* conf) {
	// Setup the NCO modulo and oversampling mode
	const uint32_t s = RADIO_CLK / 10;
	const uint8_t f3 = (s >> 24) & 0xFF;
	const uint8_t f2 = (s >> 16) & 0xFF;
	const uint8_t f1 = (s >>  8) & 0xFF;
	const uint8_t f0 = (s >>  0) & 0xFF;
	const uint8_t setup_oversampling[] = {0x11, 0x20, 0x04, 0x06, f3, f2, f1, f0};
	Si4464_write(setup_oversampling, 8);

	// Setup the NCO data rate for 2FSK
	uint8_t setup_data_rate[] = {0x11, 0x20, 0x03, 0x03, (uint8_t)(conf->speed >> 16), (uint8_t)(conf->speed >> 8), (uint8_t)conf->speed};
	Si4464_write(setup_data_rate, 7);

	// Use 2FSK from FIFO (PH)
	const uint8_t use_2fsk[] = {0x11, 0x20, 0x01, 0x00, 0x03};
	Si4464_write(use_2fsk, 5);
}

void setPowerLevel(int8_t level) {
	// Set the Power
	uint8_t set_pa_pwr_lvl_property_command[] = {0x11, 0x22, 0x01, 0x01, level};
	Si4464_write(set_pa_pwr_lvl_property_command, 5);
}

void startTx(uint16_t size) {
	uint8_t change_state_command[] = {0x31, 0x00, 0x30, (size >> 8) & 0x1F, size & 0xFF};
	Si4464_write(change_state_command, 5);
}

void stopTx(void) {
	const uint8_t change_state_command[] = {0x34, 0x03};
	Si4464_write(change_state_command, 2);
}

void startRx(void) {
	const uint8_t change_state_command[] = {0x32, 0x5E, 0x00, 0x00, 0x00, 0x00, 0x08, 0x08};
	Si4464_write(change_state_command, 8);
}

void Si4464_shutdown(void) {
	palSetLineMode(LINE_SPI_SCK, PAL_MODE_INPUT_PULLDOWN);		// SCK
	palSetLineMode(LINE_SPI_MISO, PAL_MODE_INPUT_PULLDOWN);		// MISO
	palSetLineMode(LINE_SPI_MOSI, PAL_MODE_INPUT_PULLDOWN);		// MOSI
	palSetLineMode(LINE_RADIO_CS, PAL_MODE_INPUT_PULLDOWN);		// RADIO CS
	palSetLineMode(LINE_RADIO_SDN, PAL_MODE_INPUT_PULLDOWN);	// RADIO SDN
	palSetLineMode(LINE_TCXO_EN, PAL_MODE_OUTPUT_PUSHPULL);		// Oscillator

	initialized = false;
}

/**
 * Tunes the radio and activates transmission.
 * @param frequency Transmission frequency in Hz
 * @param shift Shift of FSK in Hz
 * @param level Transmission power level in dBm
 */
bool radioTune(uint32_t frequency, uint16_t shift, int8_t level, uint16_t size) {
	// Tracing
	TRACE_INFO("SI   > Tune Si4464");

	if(!inRadioBand(frequency)) {
		TRACE_ERROR("SI   > Frequency out of range");
		TRACE_ERROR("SI   > abort transmission");
		return false;
	}

	setFrequency(frequency, shift);	// Set frequency
	setShift(shift);				// Set shift
	setPowerLevel(level);			// Set power level

	startTx(size);
	return true;
}

void Si4464_writeFIFO(uint8_t *msg, uint8_t size) {
	uint8_t write_fifo[size+1];
	write_fifo[0] = 0x66;
	memcpy(&write_fifo[1], msg, size);
	Si4464_write(write_fifo, size+1);
}

/**
  * Returns free space in FIFO of Si4464
  */
uint8_t Si4464_freeFIFO(void) {
	const uint8_t fifo_info[2] = {0x15, 0x00};
	uint8_t rxData[4];
	Si4464_read(fifo_info, 2, rxData, 4);
	return rxData[3];
}

/**
  * Returns internal state of Si4464
  */
uint8_t Si4464_getState(void) {
	const uint8_t fifo_info[1] = {0x33};
	uint8_t rxData[4];
	Si4464_read(fifo_info, 1, rxData, 4);
	return rxData[2];
}

int16_t Si4464_getTemperature(void) {
	const uint8_t txData[2] = {0x14, 0x10};
	uint8_t rxData[8];
	Si4464_read(txData, 2, rxData, 8);
	uint16_t adc = rxData[7] | ((rxData[6] & 0x7) << 8);
	return (89900*adc)/4096 - 29300;
}

int16_t Si4464_getLastTemperature(void) {
	return lastTemp;
}

